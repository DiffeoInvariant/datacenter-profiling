#include "petsc_webserver.h"
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <petscsys.h>

PetscErrorCode create_tcpaccept_entry_bag(tcpaccept_entry **entryptr, PetscBag *bagptr)
{
  PetscErrorCode ierr;
  tcpaccept_entry *entry;
  PetscBag        bag;
  PetscFunctionBeginUser;
  ierr = PetscBagCreate(PETSC_COMM_WORLD,sizeof(tcpaccept_entry),&bag);CHKERRQ(ierr);
  ierr = PetscBagGetData(bag,(void**)&entry);CHKERRQ(ierr);
  ierr = PetscBagSetName(bag,"tcpaccept_entry","An entry generated by the tcpaccept program");CHKERRQ(ierr);
  ierr = PetscBagRegisterInt(bag,&entry->pid,-1,"pid","Process ID that accepted the connection");CHKERRQ(ierr);
  ierr = PetscBagRegisterInt(bag,&entry->ip,4,"ip","IP address version");CHKERRQ(ierr);
  ierr = PetscBagRegisterInt(bag,&entry->rport,0,"rport","Remote port");CHKERRQ(ierr);
  ierr = PetscBagRegisterInt(bag,&entry->lport,0,"lport","Local port");CHKERRQ(ierr);
  ierr = PetscBagRegisterString(bag,&entry->laddr,IP_ADDR_MAX_LEN,"0.0.0.0","laddr","Local IP address");CHKERRQ(ierr);
  ierr = PetscBagRegisterString(bag,&entry->raddr,IP_ADDR_MAX_LEN,"0.0.0.0","raddr","Remote IP address");CHKERRQ(ierr);
  ierr = PetscBagRegisterString(bag,&entry->comm,COMM_MAX_LEN,"[unknown]","comm","Process name");CHKERRQ(ierr);
  
  *entryptr = entry;
  *bagptr = bag;
  PetscFunctionReturn(0);
}



PetscErrorCode buffer_create(entry_buffer *buf, size_t num_items)
{
  PetscFunctionBeginUser;
  buf->capacity = num_items;
  if (num_items < 2) {
    SETERRQ1(PETSC_COMM_WORLD,1,"Must allocate at least 2 slots in the buffer, not %D",num_items);
  }
  buf->buf = calloc(num_items,sizeof(PetscBag));
  buf->valid_start = 0;
  buf->valid_end = 0;
  buf->num_items = 0;
  PetscFunctionReturn(0);
}

PetscErrorCode buffer_destroy(entry_buffer *buf)
{
  free(&buf->buf);
  buf->valid_start = 0;
  buf->valid_end = 0;
  buf->capacity = 0;
  buf->num_items = 0;
  return 0;
}

PetscBool buffer_full(entry_buffer *buf)
{
  return (buf->num_items == buf->capacity);
}

PetscBool buffer_empty(entry_buffer *buf)
{
  return (buf->num_items == 0);
}


size_t buffer_capacity(entry_buffer *buf)
{
  return buf->capacity;
}


size_t buffer_size(entry_buffer *buf)
{
  if (!buf) {
    SETERRQ(PETSC_COMM_WORLD,PETSC_ERR_ARG_NULL,"Null buffer passed to buffer_size()!");
  }
  if (buffer_full(buf)) {
    return buf->capacity;
  }
  return buf->num_items;
}


PetscInt buffer_try_insert(entry_buffer *buf, PetscBag dataptr)
{
  if (!buf) {
    SETERRQ(PETSC_COMM_WORLD,PETSC_ERR_ARG_NULL,"Null buffer passed to buffer_try_insert()!");
  }
  if (buffer_full(buf)) {
    return -1;
  }

  buf->buf[buf->valid_end] = dataptr;
  
  buf->valid_end = (buf->valid_end + 1) % buf->capacity;
  ++(buf->num_items);
  return 0;
}

PetscErrorCode buffer_get_item(entry_buffer *buf, PetscBag *itemptr)
{
  if (buffer_empty(buf)) {
    return 0;
  }
  *itemptr = buf->buf[buf->valid_end];
  return 0;
}

PetscErrorCode buffer_next(entry_buffer *buf)
{
  buf->valid_end = (buf->valid_end + 1) % buf->capacity;
  return 0;
}
  
long get_file_end_offset(file_wrapper *file)
{
  long offset;

  fseek(file->file,0,SEEK_END);
  offset = ftell(file->file);
  file->offset = offset;
  return offset;
}


long has_new_data(file_wrapper *file)
{
  long old_offset, new_offset;
  old_offset = file->offset;
  new_offset = get_file_end_offset(file);
  fseek(file->file,old_offset,SEEK_SET);
  return new_offset - old_offset;
}

  
int next_occurance(const char *str, int curr_pos, char ch)
{
  int i = curr_pos;
  for (; str[i]; ++i) {
    if (str[i] == ch) {
      return i;
    }
  }
  return i;
}

int next_nonoccurance(const char *str, int curr_pos, char ch)
{
  int i = curr_pos;
  for (; str[i]; ++i) {
    if (str[i] != ch) {
      return i;
    }
  }
  return i;
}

int next_whitespace(const char *str, int curr_pos)
{
  return next_occurance(str,curr_pos,' ');
}

int next_nonwhitespace(const char *str, int curr_pos)
{
  return next_nonoccurance(str,curr_pos,' ');
}

PetscErrorCode parse_ipv4(const char *str, char *ip)
{
  PetscFunctionBeginUser;
  const char *format = "%15[0-9.]";
  if (sscanf(str,format,ip) != 1) {
    SETERRQ1(PETSC_COMM_WORLD,1,"Error parsing string %s for ipv4 address.",str);
  }
  PetscFunctionReturn(0);
}

PetscErrorCode parse_ipv6(const char *str, char *ip)
{
  PetscFunctionBeginUser;
  const char *format = "%39[0-9:a-z]";
  if (sscanf(str,format,ip) != 1) {
    SETERRQ1(PETSC_COMM_WORLD,1,"Error parsing string %s for ipv6 address.",str);
  }
  PetscFunctionReturn(0);
}



#define CHECK_TOKEN(str,tok,i) do {		\
  if (!tok) { \
  SETERRQ2(PETSC_COMM_WORLD,1,"Failed to find expected token number %D in string %s",i,str); \
  }\
  } while(0)



PetscErrorCode tcpaccept_entry_parse_line(tcpaccept_entry *entry, char *str)
{
  PetscErrorCode ierr;
  char *substr;
  const char sep[2] = " ";
  size_t len;
  PetscFunctionBeginUser;
  substr = strtok(str,sep);
  CHECK_TOKEN(str,substr,0);
  entry->pid = atoi(substr);
  substr = strtok(NULL,sep);
  CHECK_TOKEN(str,substr,1);
  ierr = PetscStrlen(substr,&len);CHKERRQ(ierr);
  ierr = PetscStrncpy(entry->comm,substr,len);CHKERRQ(ierr);
  substr = strtok(NULL,sep);
  CHECK_TOKEN(str,substr,2);
  entry->ip = atoi(substr);
  substr = strtok(NULL,sep);
  CHECK_TOKEN(str,substr,3);
  if (entry->ip == 4) {
    ierr = parse_ipv4(substr,entry->raddr);CHKERRQ(ierr);
  } else {
    ierr = parse_ipv6(substr,entry->raddr);CHKERRQ(ierr);
  }
  substr = strtok(NULL,sep);
  CHECK_TOKEN(str,substr,4);
  entry->rport = atoi(substr);
  substr = strtok(NULL,sep);
  CHECK_TOKEN(str,substr,5);
  if (entry->ip == 4) {
    ierr = parse_ipv4(substr,entry->laddr);CHKERRQ(ierr);
  } else {
    ierr = parse_ipv6(substr,entry->laddr);CHKERRQ(ierr);
  }
  substr = strtok(NULL,sep);
  CHECK_TOKEN(str,substr,6);
  entry->lport = atoi(substr);
  PetscFunctionReturn(0);
}
  
PetscErrorCode tcpconnect_entry_parse_line(tcpconnect_entry *entry, char *str)
{
  PetscErrorCode ierr;
  char *substr;
  const char sep[2] = " ";
  size_t len;
  PetscFunctionBeginUser;
  substr = strtok(str,sep);
  CHECK_TOKEN(str,substr,0);
  entry->pid = atoi(substr);
  substr = strtok(NULL,sep);
  CHECK_TOKEN(str,substr,1);
  ierr = PetscStrlen(substr,&len);CHKERRQ(ierr);
  ierr = PetscStrncpy(entry->comm,substr,len);CHKERRQ(ierr);
  substr = strtok(NULL,sep);
  CHECK_TOKEN(str,substr,2);
  entry->ip = atoi(substr);
  while (entry->ip == 0) {
    /* in case comm has a space */
    substr = strtok(NULL,sep);
    CHECK_TOKEN(str,substr,2);
    entry->ip = atoi(substr);
  }
  substr = strtok(NULL,sep);
  CHECK_TOKEN(str,substr,3);
  if (entry->ip == 4) {
    ierr = parse_ipv4(substr,entry->saddr);CHKERRQ(ierr);
  } else {
    ierr = parse_ipv6(substr,entry->saddr);CHKERRQ(ierr);
  }
  substr = strtok(NULL,sep);
  CHECK_TOKEN(str,substr,4);
  if (entry->ip == 4) {
    ierr = parse_ipv4(substr,entry->daddr);CHKERRQ(ierr);
  } else {
    ierr = parse_ipv6(substr,entry->daddr);CHKERRQ(ierr);
  }
  substr = strtok(NULL,sep);
  CHECK_TOKEN(str,substr,5);
  entry->dport = atoi(substr);
  PetscFunctionReturn(0);
}


PetscErrorCode create_tcpconnect_entry_bag(tcpconnect_entry **entryptr, PetscBag *bagptr)
{
  PetscErrorCode ierr;
  tcpconnect_entry *entry;
  PetscBag        bag;
  PetscFunctionBeginUser;
  ierr = PetscBagCreate(PETSC_COMM_WORLD,sizeof(tcpaccept_entry),&bag);CHKERRQ(ierr);
  ierr = PetscBagGetData(bag,(void**)&entry);CHKERRQ(ierr);
  ierr = PetscBagSetName(bag,"tcpconnect_entry","An entry generated by the tcpconnect program");CHKERRQ(ierr);
  ierr = PetscBagRegisterInt(bag,&entry->pid,-1,"pid","Process ID that requested the connection");CHKERRQ(ierr);
  ierr = PetscBagRegisterInt(bag,&entry->ip,4,"ip","IP address version");CHKERRQ(ierr);
  ierr = PetscBagRegisterInt(bag,&entry->dport,0,"dport","Destination port");CHKERRQ(ierr);
  ierr = PetscBagRegisterString(bag,&entry->saddr,IP_ADDR_MAX_LEN,"0.0.0.0","saddr","Source IP address");CHKERRQ(ierr);
  ierr = PetscBagRegisterString(bag,&entry->daddr,IP_ADDR_MAX_LEN,"0.0.0.0","daddr","Destination IP address");CHKERRQ(ierr);
  ierr = PetscBagRegisterString(bag,&entry->comm,COMM_MAX_LEN,"[unknown]","comm","Process name");CHKERRQ(ierr);
  
  *entryptr = entry;
  *bagptr = bag;
  PetscFunctionReturn(0);
}
